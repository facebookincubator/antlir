#!/usr/bin/env python3
# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

"""
This test shows off the full power of the `btrfs_diff` toolkit.

(1) Start out with the binary send-streams generated by
    `demo_sendstreams.py`, which represent subvolumes exercising all the
     core functions of btrfs.
(2) Parse & receive the send-streams into an in-memory filesystem.
(3) Ensure the subvolumes looks completely specified.
(4) Prune the "boring" metadata that is the same almost always.
(5) Render the subvolumes and compare them to "gold" rendering, which
    was manually composed from the script in `demo_sendstreams.py`.

This demonstrates that we have an essentially complete mock of btrfs, with
the ability to easily express complex assertions about send-streams and
filesystems.

In effect, we jointly test the Linux kernel, btrfs-progs, and this library.
"""
import sys

from antlir.artifacts_dir import ensure_per_repo_artifacts_dir_exists

from antlir.btrfs_diff.freeze import freeze
from antlir.btrfs_diff.rendered_tree import emit_non_unique_traversal_ids
from antlir.btrfs_diff.subvolume_set import SubvolumeSet
from antlir.btrfs_diff.tests import render_subvols as render_sv
from antlir.btrfs_diff.tests.demo_sendstreams import make_demo_sendstreams
from antlir.btrfs_diff.tests.demo_sendstreams_expected import render_demo_subvols
from antlir.fs_utils import Path
from antlir.tests.common import AntlirTestCase
from antlir.volume_for_repo import get_volume_for_current_repo


class SendstreamToSubvolumeSetIntegrationTestCase(AntlirTestCase):
    def setUp(self) -> None:
        super().setUp()
        # Make sure we have a volume to work with
        get_volume_for_current_repo(
            ensure_per_repo_artifacts_dir_exists(Path(sys.argv[0]))
        )

    def test_integration(self) -> None:
        # Generate brand-new sendstreams instead of using `gold`, since it
        # is useful for this test to exercise the live btrfs code paths as
        # new kernels and `btrfs-progs` get rolled out.  Besides checking
        # the infra, this also indirectly validates that our subvolume
        # rendering is stable and independent of the send-stream specifics.
        stream_dict = make_demo_sendstreams(Path(sys.argv[0]))
        subvols = SubvolumeSet.new()
        for d in stream_dict.values():
            render_sv.add_sendstream_to_subvol_set(subvols, d["sendstream"])
        render_sv.prepare_subvol_set_for_render(
            subvols,
            build_start_time=stream_dict["create_ops"]["build_start_time"],
            build_end_time=stream_dict["mutate_ops"]["build_end_time"],
        )

        # Rendering the subvolumes individually shows fewer clones than
        # rendering them together.
        self.assertEqual(
            render_demo_subvols(create_ops="create_ops"),
            render_sv.render_subvolume(
                # pyre-fixme[6]: For 1st param expected `Subvolume` but got
                #  `Optional[Subvolume]`.
                subvols.get_by_rendered_id("create_ops")
            ),
        )
        self.assertEqual(
            render_demo_subvols(mutate_ops="mutate_ops"),
            render_sv.render_subvolume(
                # pyre-fixme[6]: For 1st param expected `Subvolume` but got
                #  `Optional[Subvolume]`.
                subvols.get_by_rendered_id("mutate_ops")
            ),
        )
        self.assertEqual(
            render_demo_subvols(create_ops="create_ops", mutate_ops="mutate_ops"),
            freeze(subvols).map(lambda sv: emit_non_unique_traversal_ids(sv.render())),
        )
