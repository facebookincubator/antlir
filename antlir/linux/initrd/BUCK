load("//antlir/bzl:image.bzl", "image")
load("//antlir/bzl:oss_shim.bzl", "kernel_get", "python_unittest")
load("//antlir/bzl:systemd.bzl", "systemd")
load("//antlir/bzl/genrule/extractor:extract.bzl", "extract")
load("//antlir/bzl/linux:defs.bzl", "linux")
load("//antlir/linux:defs.bzl", "antlir_linux_build_opts")
load(":initrd_release.bzl", "initrd_release")
load(":systemd.bzl", "clone_systemd_configs", SYSTEMD_BINARIES = "BINARIES")

extract.source_layer(
    name = "deps",
    features = [
        image.rpms_install([
            "busybox",
            "systemd",
            "systemd-udev",
        ]),
    ],
    flavor_config_override = antlir_linux_build_opts(),
    visibility = [
        "//antlir/linux/initrd/debug/...",
    ],
)

# Generate /etc/initrd-release based on scm/fbpkg revision info
initrd_release(
    name = "initrd-release",
)

networking = [
    # Explicitly enable systemd-networkd to configure the network links
    # early in boot
    systemd.enable_unit("systemd-networkd.service"),
    image.install("units/eth.network", "/usr/lib/systemd/network/10-eth.network"),
]

# Kernel-agnostic base initrd
image.layer(
    name = "base",
    features = [
        linux.filesystem.install(),
        clone_systemd_configs(":deps"),
        image.ensure_file_symlink("/usr/lib/systemd/systemd", "/init"),
        # Systemd uses the presence of /etc/initrd-release to determine if it
        # is running in an initrd, however there are cases where it only parses
        # /{etc,usr/lib}/os-release, so just cover all our bases with symlinks
        image.install(":initrd-release", "/usr/lib/initrd-release"),
        image.ensure_file_symlink("/usr/lib/initrd-release", "/etc/initrd-release"),
        image.ensure_file_symlink("/usr/lib/initrd-release", "/usr/lib/os-release"),
        image.ensure_file_symlink("/usr/lib/initrd-release", "/etc/os-release"),
        # This is automatically the target that systemd tries to reach when it
        # detects /etc/initrd-release, but explicitly symlinking it makes
        # systemd-analyze work as expected too
        systemd.set_default_target("initrd.target"),
        systemd.install_dropin(
            "dropins/udevd-before-trigger.conf",
            unit = "systemd-udevd.service",
        ),
        networking,
        # Due to limitations in the current extractor implementation, we have to
        # extract systemd at the same time as antlirctl.
        extract.extract(
            binaries = SYSTEMD_BINARIES,
            buck_binaries = {
                "//antlir/linux/antlirctl:antlirctl": "/usr/bin/antlirctl",
            },
            dest = "/",
            source = ":deps",
        ),
        # antlirctl provides /usr/bin/mount so we can avoid importing busybox
        image.ensure_file_symlink("/usr/bin/antlirctl", "/usr/bin/mount"),
    ],
    flavor_config_override = antlir_linux_build_opts(),
    visibility = [kernel_get.base_target + "/..."],
)

# CPIO archive to which environment specific overlays are appended. For
# example, vmtest appends units that load required kernel modules and sets up
# the BTRFS seed device on /
image.package(
    name = "base.cpio.gz",
    layer = ":base",
    visibility = ["PUBLIC"],
    build_appliance = antlir_linux_build_opts().build_appliance,
)

python_unittest(
    name = "base-size",
    srcs = ["tests/check_size.py"],
    env = {"BASE_PACKAGE": "$(location :base.cpio.gz)"},
    deps = ["//antlir:config"],
)
