load("//antlir/bzl:build_defs.bzl", "export_file", "python_unittest", "rust_binary")
load("//antlir/bzl:image.bzl", "image")
load("//antlir/bzl:image_unittest_helpers.bzl", helpers = "image_unittest_helpers")
load("//antlir/bzl:kernel_shim.bzl", "kernels")
load("//antlir/bzl:shape.bzl", "shape")
load("//antlir/bzl:systemd.bzl", "ADMIN_ROOT", "systemd")
load("//antlir/bzl/image/feature:defs.bzl", "feature")
load("//antlir/bzl/image/package:defs.bzl", "package")
load("//antlir/vm/bzl:defs.bzl", "vm")
load("//antlir/vm/bzl:initrd.bzl", "initrd")
load("//metalos/os/tests:defs.bzl", "fail_unit")

oncall("twimage")

# Future: when we run a VM the tap device is actually created
# on the host, but this test runs inside a VM, which needs
# a tap device...  Yes, this is circular, since tap devices
# are created inside of network namespaces (always), it *should*
# be ok to run this inside of a regular test instead.  However,
# this needs to run as root... so really this should probably
# be run inside a container instead of a vm.
vm.python_unittest(
    name = "test-tap",
    srcs = ["test_tap.py"],
    deps = [
        "//antlir:testlib_common",
        "//antlir/vm:tap",
    ],
)

initrd(
    name = "initrd-fail-metalinit",
    features = [
        fail_unit("metalos-init.service"),
    ],
    kernel = kernels.default,
)

python_unittest(
    name = "test-vm",
    srcs = [
        "test_share_generator.py",
        "test_vm.py",
    ],
    env = {
        "test-vm-initrd-fail-json": shape.do_not_cache_me_json(
            vm.types.opts.new(
                initrd = ":initrd-fail-metalinit",
            ),
        ),
        "test-vm-json": shape.do_not_cache_me_json(
            vm.types.opts.new(
                disk = vm.types.disk.root(
                    # to cover the additional_scratch_mb branch in antlir/vm/share.py
                    disk_free_mb = 2048,
                    interface = "virtio-blk",
                    layer = ":vmtest-custom-layer",
                ),
                runtime = vm.types.runtime.new(
                    connection = vm.types.connection.new(
                        # Test using ssh options
                        options = {
                            "ServerAliveCountMax": "1",
                            "ServerAliveInterval": "1",
                        },
                    ),
                    tpm = True,
                ),
            ),
        ),
        "test-vm-nvme-json": shape.do_not_cache_me_json(
            vm.types.opts.new(
                disk = vm.types.disk.root(
                    interface = "nvme",
                    layer = ":vmtest-custom-layer",
                ),
            ),
        ),
        "test-vm-sata-json": shape.do_not_cache_me_json(
            vm.types.opts.new(
                disk = vm.types.disk.root(
                    interface = "ide-hd",
                    layer = ":vmtest-custom-layer",
                ),
            ),
        ),
        "test-vm-sidecar-json": shape.do_not_cache_me_json(
            vm.types.opts.new(
                runtime = vm.types.runtime.new(
                    sidecar_services = ["/bin/sleep 3600"],
                ),
            ),
        ),
    },
    needed_coverage = [
        (100, "//antlir/vm:vm"),
        (100, "//antlir/vm:share"),
        (100, "//antlir/vm:guest-ssh"),
    ],
    resources = {
        "//antlir/vm:mount-generator": "mount-generator",
    },
    supports_static_listing = True,
    deps = [
        "//antlir:fs_utils",
        "//antlir:testlib_common",
        "//antlir:unshare",
        "//antlir/vm:mount-generator",
        "//antlir/vm:share",
        "//antlir/vm:vm",
    ],
)

# Don't run this test directly, it should only be used within
# `:test-kernel-panic`.
vm.python_unittest(
    name = "create-kernel-panic",
    srcs = ["create_kernel_panic.py"],
    labels = helpers.tags_to_hide_test(),
    visibility = [],
    vm_opts = vm.types.opts.new(
        runtime = vm.types.runtime.new(
            connection = vm.types.connection.new(
                # Set the options such that it fails fast when
                # the vm crashes.  This is just to make the test
                # run in a reasonable amount of time.
                options = {
                    "ServerAliveCountMax": "1",
                    "ServerAliveInterval": "1",
                },
            ),
        ),
    ),
)

python_unittest(
    name = "test-kernel-panic",
    srcs = ["test_kernel_panic.py"],
    resources = {
        ":create-kernel-panic=vmtest": "create-kernel-panic",
    },
    supports_static_listing = True,
    deps = [
        ":create-kernel-panic",
        "//antlir:fs_utils",
        "//antlir:testlib_common",
        "//antlir/nspawn_in_subvol:common",
    ],
)

# To test initrd.break functionality override the default
# debug-shell.conf behavior. Instead of spawning a shell we'll dump some
# debug information and then halt the VM.
image.layer(
    name = "vmtest-initrd-break-custom-initrd-layer",
    features = [
        #
        # This override is installed into ADMIN_ROOT (/etc/systemd/system)
        # because it's overriding the existing debug-shell.conf override
        # in PROVIDER_ROOT (/usr/lib/systemd/system).
        #
        feature.ensure_subdirs_exist("/", ADMIN_ROOT),
        systemd.install_dropin(
            dest = "override.conf",
            install_root = ADMIN_ROOT,
            source = "debug-shell-exec-override.conf",
            unit = "debug-shell.service",
        ),
    ],
    parent_layer = "//antlir/vm/initrd:{}-initrd-layer".format(
        kernels.default.uname,
    ),
)

package.new(
    name = "vmtest-initrd-break-custom-initrd",
    format = "cpio.gz",
    layer = ":vmtest-initrd-break-custom-initrd-layer",
)

# Create a VM to test booting with "initrd.break" set
vm.run(
    name = "vmtest-initrd-break-default",
    vm_opts = vm.types.opts.new(
        append = ["initrd.break"],
        initrd = ":vmtest-initrd-break-custom-initrd",
        runtime = vm.types.runtime.new(
            connection = vm.types.connection.new(
                # Set the options such that it fails fast when
                # the vm crashes.  This is just to make the test
                # run in a reasonable amount of time.
                options = {
                    "ServerAliveCountMax": "1",
                    "ServerAliveInterval": "1",
                },
            ),
        ),
    ),
)

# TODO(T120961487) Fix this later
# python_unittest(
#     name = "test-initrd-break",
#     srcs = ["test_initrd_break.py"],
#     resources = {
#         ":vmtest-initrd-break-default": "vmtest-initrd-break-default",
#     },
#     deps = [
#         ":vmtest-initrd-break-default",
#         "//antlir:fs_utils",
#         "//antlir:testlib_common",
#         "//antlir/nspawn_in_subvol:common",
#     ],
# )

export_file(name = "resource.txt")

test_env_vars = {
    "dogsgo": "woof",
    "kitteh": "meow",
}

image.layer(
    name = "vmtest-custom-layer",
    features = [
        feature.install(
            ":resource.txt",
            "/etc/i_am_a_custom_rootfs",
        ),
    ],
    parent_layer = vm.artifacts.rootfs.layer,
)

vm.python_unittest(
    name = "python",
    srcs = [
        "test_basic_vm.py",
        "test_vm_boot.py",
    ],
    env = test_env_vars,
    resources = {
        ":resource.txt": "resource",
    },
    vm_opts = vm.types.opts.new(
        cpus = 4,
        disk = vm.types.disk.root(
            layer = ":vmtest-custom-layer",
        ),
    ),
    deps = [
        ":resource.txt",
        "//antlir:fs_utils",
        "//antlir:testlib_common",
    ],
)

vm.python_unittest(
    name = "python-multinics",
    srcs = [
        "test_multinics_vm.py",
    ],
    env = test_env_vars,
    resources = {
        ":resource.txt": "resource",
    },
    vm_opts = vm.types.opts.new(
        cpus = 1,
        disk = vm.types.disk.root(
            layer = ":vmtest-custom-layer",
        ),
        nics = 4,
    ),
    deps = [
        ":resource.txt",
        "//antlir:fs_utils",
        "//antlir:testlib_common",
    ],
)

vm.cpp_unittest(
    name = "cpp",
    srcs = ["CppTest.cpp"],
    env = test_env_vars,
)

vm.rust_unittest(
    name = "rust",
    srcs = ["rust_test.rs"],
    crate_root = "rust_test.rs",
    env = test_env_vars,
)

image.layer(
    name = "rootfs-with-buck-runnables",
    features = ["//antlir/compiler/test_images:systemd_buck_runnables"],
    parent_layer = vm.artifacts.rootfs.layer,
)

vm.python_unittest(
    name = "test-buck-runnable",
    srcs = ["test_buck_runnable.py"],
    vm_opts = vm.types.opts.new(
        disk = vm.types.disk.root(layer = ":rootfs-with-buck-runnables"),
    ),
    deps = [
        "//antlir:fs_utils",
        "//antlir:testlib_common",
    ],
)

vm.python_unittest(
    name = "test-with-kernel-devel",
    srcs = ["test_kernel_devel.py"],
    vm_opts = vm.types.opts.new(
        devel = True,
    ),
    deps = [
        "//antlir:testlib_common",
    ],
)

vm.python_unittest(
    name = "test-many-disks",
    srcs = ["test_many_disks.py"],
    vm_opts = vm.types.opts.new(
        disks = [
            vm.types.disk.root(),
        ] + [
            vm.types.disk.scratch(
                size_mb = 16,
            ),
        ] * 36,
    ),
    deps = [
        "//antlir:fs_utils",
        "//antlir:testlib_common",
    ],
)

rust_binary(
    name = "sidecar",
    srcs = ["sidecar.rs"],
    deps = [
        "tokio",
    ],
)

vm.rust_unittest(
    name = "with-sidecar",
    srcs = ["test_with_sidecar.rs"],
    crate_root = "test_with_sidecar.rs",
    vm_opts = vm.types.opts.new(
        runtime = vm.types.runtime.new(
            sidecar_services = ["$(exe :sidecar)"],
        ),
    ),
    deps =
        [
            "anyhow",
            "tokio",
        ],
)
