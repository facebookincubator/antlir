# @noautodeps

load("//antlir/bzl:image.bzl", "image")
load("//antlir/bzl:image_unittest_helpers.bzl", helpers = "image_unittest_helpers")
load("//antlir/bzl:oss_shim.bzl", "export_file", "kernel_get", "python_unittest", "rust_binary", "third_party")
load("//antlir/bzl:shape.bzl", "shape")
load("//antlir/bzl:systemd.bzl", "ADMIN_ROOT", "systemd")
load("//antlir/bzl/image/feature:defs.bzl", "feature")
load("//antlir/bzl/image/package:btrfs.bzl", "btrfs")
load("//antlir/bzl/image/package:defs.bzl", "package")
load("//antlir/bzl/linux/boot:defs.bzl", "boot")
load("//antlir/vm/bzl:defs.bzl", "vm")

# Future: when we run a VM the tap device is actually created
# on the host, but this test runs inside a VM, which needs
# a tap device...  Yes, this is circular, since tap devices
# are created inside of network namespaces (always), it *should*
# be ok to run this inside of a regular test instead.  However,
# this needs to run as root... so really this should probably
# be run inside a container instead of a vm.
vm.python_unittest(
    name = "test-tap",
    srcs = ["test_tap.py"],
    deps = [
        "//antlir:testlib_common",
        "//antlir/vm:tap",
    ],
)

python_unittest(
    name = "test-vm",
    srcs = [
        "test_share_generator.py",
        "test_vm.py",
    ],
    env = {
        "test-vm-json": shape.do_not_cache_me_json(
            vm.types.opts.new(
                runtime = vm.types.runtime.new(
                    connection = vm.types.connection.new(
                        # Test using ssh options
                        options = {
                            "ServerAliveCountMax": "1",
                            "ServerAliveInterval": "1",
                        },
                    ),
                    tpm = True,
                ),
                disk = vm.types.disk.new(
                    layer = ":vmtest-custom-layer",
                    # to cover the additional_scratch_mb branch in antlir/vm/share.py
                    additional_scratch_mb = 2048,
                ),
            ),
        ),
        "test-vm-sidecar-json": shape.do_not_cache_me_json(
            vm.types.opts.new(
                runtime = vm.types.runtime.new(
                    sidecar_services = ["/bin/sleep 3600"],
                ),
            ),
        ),
    },
    needed_coverage = [
        (100, "//antlir/vm:vm"),
        (100, "//antlir/vm:share"),
        (100, "//antlir/vm:guest-ssh"),
    ],
    resources = {
        "//antlir/vm:mount-generator": "mount-generator",
    },
    deps = [
        "//antlir:fs_utils",
        "//antlir:testlib_common",
        "//antlir:unshare",
        "//antlir/vm:share",
        "//antlir/vm:vm",
    ],
)

# Don't run this test directly, it should only be used within
# `:test-kernel-panic`.
vm.python_unittest(
    name = "create-kernel-panic",
    srcs = ["create_kernel_panic.py"],
    tags = helpers.tags_to_hide_test(),
    visibility = [],
    vm_opts = vm.types.opts.new(
        runtime = vm.types.runtime.new(
            connection = vm.types.connection.new(
                # Set the options such that it fails fast when
                # the vm crashes.  This is just to make the test
                # run in a reasonable amount of time.
                options = {
                    "ServerAliveCountMax": "1",
                    "ServerAliveInterval": "1",
                },
            ),
        ),
    ),
)

python_unittest(
    name = "test-kernel-panic",
    srcs = ["test_kernel_panic.py"],
    resources = {
        ":create-kernel-panic=vmtest": "create-kernel-panic",
    },
    deps = [
        ":create-kernel-panic",
        "//antlir:fs_utils",
        "//antlir:testlib_common",
        "//antlir/nspawn_in_subvol:common",
    ],
)

# To test initrd.break functionality override the default
# debug-shell.conf behavior. Instead of spawning a shell we'll dump some
# debug information and then halt the VM.
image.layer(
    name = "vmtest-initrd-break-custom-initrd-layer",
    parent_layer = "{}:{}-initrd-layer".format(
        kernel_get.base_target,
        kernel_get.default.uname,
    ),
    features = [
        #
        # This override is installed into ADMIN_ROOT (/etc/systemd/system)
        # because it's overriding the existing debug-shell.conf override
        # in PROVIDER_ROOT (/usr/lib/systemd/system).
        #
        image.ensure_subdirs_exist("/", ADMIN_ROOT),
        systemd.install_dropin(
            source = "debug-shell-exec-override.conf",
            dest = "override.conf",
            unit = "debug-shell.service",
            install_root = ADMIN_ROOT,
        ),
    ],
)

package.new(
    name = "vmtest-initrd-break-custom-initrd",
    layer = ":vmtest-initrd-break-custom-initrd-layer",
    format = "cpio.gz",
)

# Create a VM to test booting with "initrd.break" set
vm.run(
    name = "vmtest-initrd-break-default",
    vm_opts = vm.types.opts.new(
        runtime = vm.types.runtime.new(
            connection = vm.types.connection.new(
                # Set the options such that it fails fast when
                # the vm crashes.  This is just to make the test
                # run in a reasonable amount of time.
                options = {
                    "ServerAliveCountMax": "1",
                    "ServerAliveInterval": "1",
                },
            ),
        ),
        append = ["initrd.break"],
        initrd = ":vmtest-initrd-break-custom-initrd",
    ),
)

# Create a VM to test booting with "initrd.break=sysinit.target" set
vm.run(
    name = "vmtest-initrd-break-custom",
    vm_opts = vm.types.opts.new(
        runtime = vm.types.runtime.new(
            connection = vm.types.connection.new(
                # Set the options such that it fails fast when
                # the vm crashes.  This is just to make the test
                # run in a reasonable amount of time.
                options = {
                    "ServerAliveCountMax": "1",
                    "ServerAliveInterval": "1",
                },
            ),
        ),
        append = ["initrd.break=sysinit.target"],
        initrd = ":vmtest-initrd-break-custom-initrd",
    ),
)

python_unittest(
    name = "test-initrd-break",
    srcs = ["test_initrd_break.py"],
    resources = {
        ":vmtest-initrd-break-custom": "vmtest-initrd-break-custom",
        ":vmtest-initrd-break-default": "vmtest-initrd-break-default",
    },
    deps = [
        ":vmtest-initrd-break-custom",
        ":vmtest-initrd-break-default",
        "//antlir:fs_utils",
        "//antlir:testlib_common",
        "//antlir/nspawn_in_subvol:common",
    ],
)

export_file(name = "resource.txt")

test_env_vars = {
    "dogsgo": "woof",
    "kitteh": "meow",
}

image.layer(
    name = "vmtest-custom-layer",
    parent_layer = vm.artifacts.rootfs.layer,
    features = [
        feature.install(
            ":resource.txt",
            "/etc/i_am_a_custom_rootfs",
        ),
    ],
)

vm.python_unittest(
    name = "python",
    srcs = [
        "test_basic_vm.py",
        "test_vm_boot.py",
    ],
    env = test_env_vars,
    resources = {
        ":resource.txt": "resource",
    },
    vm_opts = vm.types.opts.new(
        cpus = 4,
        disk = vm.types.disk.new(
            layer = ":vmtest-custom-layer",
        ),
    ),
    deps = [
        "//antlir:fs_utils",
        "//antlir:testlib_common",
    ],
)

vm.cpp_unittest(
    name = "cpp",
    srcs = ["CppTest.cpp"],
    env = test_env_vars,
)

vm.rust_unittest(
    name = "rust",
    srcs = ["rust_test.rs"],
    env = test_env_vars,
    crate_root = "rust_test.rs",
)

image.layer(
    name = "rootfs-with-buck-runnables",
    parent_layer = vm.artifacts.rootfs.layer,
    features = ["//antlir/compiler/test_images:systemd_buck_runnables"],
)

vm.python_unittest(
    name = "test-buck-runnable",
    srcs = ["test_buck_runnable.py"],
    vm_opts = vm.types.opts.new(
        disk = vm.types.disk.new(layer = ":rootfs-with-buck-runnables"),
    ),
    deps = [
        "//antlir:fs_utils",
        "//antlir:testlib_common",
    ],
)

vm.python_unittest(
    name = "test-with-kernel-devel",
    srcs = ["test_kernel_devel.py"],
    vm_opts = vm.types.opts.new(
        devel = True,
    ),
    deps = [
        "//antlir:testlib_common",
    ],
)

rust_binary(
    name = "sidecar",
    srcs = ["sidecar.rs"],
    deps = [
        third_party.library(
            "tokio",
            platform = "rust",
        ),
    ],
)

vm.rust_unittest(
    name = "with-sidecar",
    srcs = ["test_with_sidecar.rs"],
    vm_opts = vm.types.opts.new(
        runtime = vm.types.runtime.new(
            sidecar_services = ["$(exe :sidecar)"],
        ),
    ),
    crate_root = "test_with_sidecar.rs",
    deps = third_party.libraries(
        [
            "anyhow",
            "tokio",
        ],
        platform = "rust",
    ),
)

boot.systemd.build(
    # The target name of the boot partition
    name = "systemd-boot",
    kernels = [
        kernel_get.default,
    ],
    args = [
        "audit=0",
        "rootflags=subvol=volume,rw",
        "systemd.hostname=vmtest",
    ],
)

btrfs.new(
    name = "root-disk",
    opts = btrfs.opts.new(
        subvols = {
            "/volume": btrfs.opts.subvol.new(
                layer = ":vmtest-custom-layer",
                writable = True,
            ),
        },
        loopback_opts = image.opts(
            label = "/",
        ),
    ),
)

image.gpt(
    name = "gpt-systemd-boot-disk",
    table = [
        image.gpt_partition(
            package = ":systemd-boot",
            is_esp = True,
        ),
        image.gpt_partition(
            package = ":root-disk",
        ),
    ],
)

vm.python_unittest(
    name = "test-systemd-boot-from-disk",
    srcs = ["test_vm_boot.py"],
    vm_opts = vm.types.opts.new(
        boot_from_disk = True,
        disk = vm.types.disk.new(
            package = ":gpt-systemd-boot-disk",
        ),
    ),
    deps = [
        "//antlir:fs_utils",
        "//antlir:testlib_common",
    ],
)

boot.grub2.build(
    # The target name of the boot partition
    name = "grub2-boot",
    kernels = [
        kernel_get.default,
    ],
    args = [
        "audit=0",
        "rootflags=subvol=volume,rw",
        "systemd.hostname=vmtest",
    ],
)

image.gpt(
    name = "gpt-grub2-boot-disk",
    table = [
        image.gpt_partition(
            package = ":grub2-boot",
            is_esp = True,
        ),
        image.gpt_partition(
            package = ":root-disk",
        ),
    ],
)

vm.python_unittest(
    name = "test-grub2-boot-from-disk",
    srcs = ["test_vm_boot.py"],
    vm_opts = vm.types.opts.new(
        boot_from_disk = True,
        disk = vm.types.disk.new(
            package = ":gpt-grub2-boot-disk",
        ),
    ),
    deps = [
        "//antlir:fs_utils",
        "//antlir:testlib_common",
    ],
)
