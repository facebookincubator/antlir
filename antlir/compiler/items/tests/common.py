#!/usr/bin/env python3
# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

import functools
import os
import subprocess
import tempfile
import unittest
from contextlib import contextmanager
from unittest import mock

from antlir.compiler.items.common import assert_running_inside_ba, LayerOpts

from antlir.compiler.requires_provides import (
    ProvidesDirectory,
    ProvidesFile,
    ProvidesSymlink,
)
from antlir.fs_utils import Path
from antlir.nspawn_in_subvol.args import new_nspawn_opts, PopenArgs
from antlir.nspawn_in_subvol.nspawn import run_nspawn
from antlir.subvol_utils import Subvol
from antlir.tests.layer_resource import layer_resource_subvol
from antlir.tests.subvol_helpers import pop_path, render_subvol


# Re-export for legacy reasons
pop_path = pop_path
render_subvol = render_subvol

DEFAULT_STAT_OPTS = ["--user=root", "--group=root", "--mode=0755"]
DUMMY_LAYER_OPTS = LayerOpts(
    layer_target="fake target",  # Only used by error messages
    build_appliance=None,
    # For a handful of tests, this must be a boolean value so the layer
    # emits it it into /.meta, but the value is not important.
    artifacts_may_require_repo=True,
    # pyre-fixme[6]: Expected `Mapping[str, str]` for 4th param but got `None`.
    target_to_path=None,
    # pyre-fixme[6]: Expected `Path` for 5th param but got `None`.
    subvolumes_dir=None,
    rpm_installer=None,
    version_set_override=None,
    rpm_repo_snapshot=None,
    # pyre-fixme[6]: Expected `frozenset[str]` for 9th param but got
    #  `List[Variable[_T]]`.
    allowed_host_mount_targets=[],
    flavor="antlir_test",
    apt_repo_snapshot=(),
)


# This has to be a function because using `importlib` while loading a module
# results in incorrect behavior (I did not debug the specifics).
def get_dummy_layer_opts_ba(ba_subvol=None):
    return DUMMY_LAYER_OPTS._replace(
        build_appliance=ba_subvol
        or layer_resource_subvol(__package__, "test-build-appliance")
    )


def populate_temp_filesystem(img_path) -> None:
    "Matching Provides are generated by _temp_filesystem_provides"

    def p(img_rel_path):
        return os.path.join(img_path, img_rel_path)

    os.makedirs(p("a/b/c"))
    os.makedirs(p("a/d"))

    for filepath in ["a/E", "a/d/F", "a/b/c/G"]:
        with open(p(filepath), "w") as f:
            f.write("Hello, " + filepath)

    os.symlink("a", p("h"))
    os.symlink("a/E", p("i"))
    os.symlink("./a/b", p("j"))
    os.symlink("../a", p("h/k"))
    os.symlink("/a", p("l"))
    os.symlink("/a/E", p("m"))


@contextmanager
def temp_filesystem():
    with tempfile.TemporaryDirectory() as td_path:
        populate_temp_filesystem(td_path)
        yield td_path


def temp_filesystem_provides(p: str = ""):
    "Captures what is provided by _temp_filesystem, if installed at `p`"
    "inside the image."
    return {
        ProvidesDirectory(path=Path(f"{p}/a")),
        ProvidesDirectory(path=Path(f"{p}/a/b")),
        ProvidesDirectory(path=Path(f"{p}/a/b/c")),
        ProvidesDirectory(path=Path(f"{p}/a/d")),
        ProvidesFile(path=Path(f"{p}/a/E")),
        ProvidesFile(path=Path(f"{p}/a/d/F")),
        ProvidesFile(path=Path(f"{p}/a/b/c/G")),
        ProvidesSymlink(path=Path(f"{p}/h"), target=(Path("a"))),
        ProvidesSymlink(path=Path(f"{p}/i"), target=(Path("a/E"))),
        ProvidesSymlink(path=Path(f"{p}/j"), target=(Path("./a/b"))),
        ProvidesSymlink(path=Path(f"{p}/a/k"), target=(Path("../a"))),
        ProvidesSymlink(path=Path(f"{p}/l"), target=(Path("/a"))),
        ProvidesSymlink(path=Path(f"{p}/m"), target=(Path("/a/E"))),
    }


def run_in_ba(layer: Subvol, cmd) -> subprocess.CompletedProcess:
    res, _ = run_nspawn(
        new_nspawn_opts(
            cmd=cmd,
            layer=layer,
        ),
        PopenArgs(
            stdout=subprocess.PIPE,
        ),
    )
    return res


def getent(layer: Subvol, dbtype: str, name: str) -> bytes:
    return run_in_ba(
        cmd=["getent", dbtype, name],
        layer=layer,
    ).stdout


class BaseItemTestCase(unittest.TestCase):
    def setUp(self) -> None:  # More output for easier debugging
        unittest.util._MAX_LENGTH = 12345
        self.maxDiff = 12345

    def _check_item(self, i, provides, requires) -> None:
        self.assertEqual(provides, set(i.provides()))
        self.assertEqual(requires, set(i.requires()))


def with_mocked_temp_volume_dir(method):
    assert_running_inside_ba()

    @functools.wraps(method)
    def decorated(self, *args, **kwargs):
        with mock.patch(
            "antlir.subvol_utils._tmp_volume_dir",
            mock.Mock(return_value=Path("/")),
        ):
            return method(self, *args, **kwargs)

    return decorated
