/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

use std::collections::HashMap;
use std::path::PathBuf;

use antlir2_compile::CompileFeature;
use antlir2_depgraph::Graph;
use antlir2_rootless::Rootless;
use anyhow::Context;
use clap::Parser;
use json_arg::JsonFile;

use super::Compileish;
use crate::Result;

#[derive(Parser, Debug)]
/// Compile image features into a directory
pub(crate) struct Compile {
    #[clap(flatten)]
    pub(super) compileish: Compileish,
    #[clap(flatten)]
    /// Pre-computed plan for this compilation phase
    pub(super) external: CompileExternal,
}

#[derive(Parser, Debug)]
/// Compile arguments that are _always_ passed from external sources (in other
/// words, by buck2 actions) and are never generated by internal code in the
/// 'isolate' subcommand.
pub(super) struct CompileExternal {
    #[clap(long)]
    /// Pre-computed plans for this compilation phase
    plans: JsonFile<HashMap<String, PathBuf>>,
}

impl Compile {
    #[tracing::instrument(name = "compile", skip(self, rootless), ret, err)]
    pub(crate) fn run(self, rootless: Option<Rootless>) -> Result<()> {
        let plans = self
            .external
            .plans
            .into_inner()
            .into_iter()
            .map(|(id, path)| {
                let plan = std::fs::read_to_string(&path)
                    .with_context(|| format!("while reading plan '{}'", path.display()))?;
                let plan = serde_json::from_str(&plan)
                    .with_context(|| format!("while parsing plan '{}'", path.display()))?;
                Ok((id, plan))
            })
            .collect::<Result<_>>()?;
        let ctx = self.compileish.compiler_context(plans)?;
        let root_guard = rootless.map(|r| r.escalate()).transpose()?;
        let depgraph =
            Graph::open(self.compileish.external.depgraph).context("while opening depgraph")?;
        for feature in depgraph
            .pending_features()
            .context("while fetching pending features")?
        {
            feature.compile(&ctx)?;
        }
        drop(root_guard);
        Ok(())
    }
}
