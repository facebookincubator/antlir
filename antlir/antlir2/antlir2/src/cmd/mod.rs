/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

use std::borrow::Cow;
use std::collections::BTreeMap;
use std::collections::BTreeSet;
use std::ffi::OsStr;
use std::path::PathBuf;

use antlir2_compile::Arch;
use antlir2_compile::CompilerContext;
use antlir2_compile::DnfContext;
use antlir2_depgraph::Graph;
use buck_label::Label;
use clap::Parser;
use json_arg::JsonFile;

use crate::Error;
use crate::Result;

mod compile;
mod depgraph;
mod map;
mod plan;
mod shell;
#[cfg(facebook)]
use antlir2_compile::facebook::FbpkgContext;
#[cfg(facebook)]
use antlir2_compile::facebook::ResolvedFbpkgInfoJsonFile;
pub(crate) use compile::Compile;
pub(crate) use depgraph::Depgraph;
pub(crate) use map::Map;
pub(crate) use plan::Plan;
pub(crate) use shell::Shell;

/// Args that are common to "compileish" commands (for now, 'compile' and
/// 'plan', but maybe others in the future)
#[derive(Parser, Debug)]
pub(self) struct Compileish {
    #[clap(long)]
    /// Buck label of the image being built
    pub(crate) label: Label<'static>,
    #[clap(long)]
    /// Root directory of under-construction image. Must already exist (either
    /// empty or as a snapshot of a parent layer)
    pub(crate) root: PathBuf,
    #[clap(flatten)]
    pub(crate) external: CompileishExternal,
    #[clap(flatten)]
    pub(crate) dnf: DnfCompileishArgs,
    #[cfg(facebook)]
    #[clap(flatten)]
    pub(crate) fbpkg: FbpkgCompileishArgs,
}

#[derive(Parser, Debug)]
pub(self) struct DnfCompileishArgs {
    #[clap(long = "dnf-repos")]
    /// Path to available dnf repositories
    pub(crate) repos: PathBuf,
    #[clap(long = "dnf-versionlock")]
    /// Path to dnf versionlock json file
    pub(crate) versionlock: Option<JsonFile<BTreeMap<String, String>>>,
    #[clap(long = "dnf-excluded-rpms")]
    /// Path to json file with list of rpms to exclude from dnf operations
    pub(crate) excluded_rpms: Option<JsonFile<BTreeSet<String>>>,
}

#[cfg(facebook)]
#[derive(Parser, Debug)]
pub(self) struct FbpkgCompileishArgs {
    #[clap(long = "resolved-fbpkgs")]
    /// Path to resolced fbpkgs json file
    pub(crate) resolved_fbpkgs: Option<ResolvedFbpkgInfoJsonFile>,
}

#[derive(Parser, Debug)]
/// Compile arguments that are _always_ passed from external sources (in other
/// words, by buck2 actions) and are never generated by internal code in the
/// 'isolate' subcommand.
pub(self) struct CompileishExternal {
    #[clap(long)]
    /// Architecture of the image being built
    pub(crate) target_arch: Arch,
    #[clap(long = "depgraph-json")]
    /// Path to input depgraph json file with features to include in this image
    pub(crate) depgraph: JsonFile<Graph<'static>>,
    #[clap(long = "image-dependency")]
    pub(crate) image_dependencies: Vec<PathBuf>,
}

impl Compileish {
    #[deny(unused_variables)]
    pub(self) fn to_args<'a>(&'a self) -> Vec<Cow<'a, OsStr>> {
        let Self {
            external:
                CompileishExternal {
                    target_arch,
                    depgraph,
                    image_dependencies,
                },
            label,
            root,
            dnf:
                DnfCompileishArgs {
                    repos: dnf_repos,
                    versionlock: dnf_versionlock,
                    excluded_rpms: dnf_excluded_rpms,
                },
            #[cfg(facebook)]
                fbpkg: FbpkgCompileishArgs { resolved_fbpkgs },
        } = self;
        let mut v = vec![
            Cow::Borrowed(OsStr::new("--label")),
            Cow::Owned(label.to_string().into()),
            Cow::Borrowed(OsStr::new("--target-arch")),
            Cow::Owned(target_arch.to_string().into()),
            Cow::Borrowed(OsStr::new("--depgraph-json")),
            Cow::Borrowed(depgraph.path().as_os_str()),
            Cow::Borrowed(OsStr::new("--root")),
            Cow::Borrowed(root.as_os_str()),
            Cow::Borrowed(OsStr::new("--dnf-repos")),
            Cow::Borrowed(dnf_repos.as_os_str()),
        ];
        if let Some(versionlock) = dnf_versionlock {
            v.push(Cow::Borrowed(OsStr::new("--dnf-versionlock")));
            v.push(Cow::Borrowed(versionlock.path().as_os_str()));
        }
        if let Some(excluded_rpms) = dnf_excluded_rpms {
            v.push(Cow::Borrowed(OsStr::new("--dnf-excluded-rpms")));
            v.push(Cow::Borrowed(excluded_rpms.path().as_os_str()));
        }
        #[cfg(facebook)]
        if let Some(resolved_fbpkgs) = resolved_fbpkgs {
            v.push(Cow::Borrowed(OsStr::new("--resolved-fbpkgs")));
            v.push(Cow::Borrowed(resolved_fbpkgs.path().as_os_str()));
        }
        for dep in image_dependencies {
            v.push(Cow::Borrowed(OsStr::new("--image-dependency")));
            v.push(Cow::Borrowed(dep.as_os_str()));
        }
        v
    }

    pub(super) fn compiler_context(
        &self,
        plan: Option<antlir2_compile::plan::Plan>,
    ) -> Result<CompilerContext> {
        CompilerContext::new(
            self.label.clone(),
            self.external.target_arch,
            self.root.clone(),
            DnfContext::new(
                self.dnf.repos.clone(),
                self.dnf.versionlock.clone(),
                self.dnf
                    .excluded_rpms
                    .as_ref()
                    .map(JsonFile::as_inner)
                    .cloned()
                    .unwrap_or_default(),
            ),
            plan,
            #[cfg(facebook)]
            FbpkgContext::new(self.fbpkg.resolved_fbpkgs.clone()),
        )
        .map_err(Error::Compile)
    }
}
