load("//antlir/bzl:flavor_helpers.bzl", "flavor_helpers")
load("//antlir/bzl:image.bzl", "image")
load("//antlir/bzl:kernel_shim.bzl", "kernels")
load("//antlir/bzl:oss_shim.bzl", "third_party")
load("//antlir/bzl/image/feature:defs.bzl", "feature")
load("//antlir/bzl/image/package:btrfs.bzl", "btrfs")
load("//antlir/bzl/image/package:defs.bzl", "package")
load("//antlir/vm/bzl:defs.bzl", "vm")
load(":hash.bzl", "pe_hash")

image.layer(
    name = "efi",
    features = [
        feature.ensure_dirs_exist("/EFI/BOOT"),
        # QEMU UEFI looks at /EFI/BOOT/BOOTX64.efi by default
        # On prod systems, we install a boot entry explicitly pointing to the
        # location of the installed bootloader
        feature.install("//metalos/bootloader:bootloader.efi", "/EFI/BOOT/BOOTX64.efi"),
    ],
    flavor = flavor_helpers.get_antlir_linux_flavor(),
    visibility = [],
)

package.new(
    name = "efi.vfat",
    format = "vfat",
    layer = ":efi",
    loopback_opts = image.opts(
        label = "efi",
        size_mb = 256,
    ),
)

TEST_KERNEL = kernels.default

image.layer(
    name = "control",
    features = [
        feature.ensure_dirs_exist("/run/state/metalos"),
        feature.ensure_dirs_exist("/image/initrd"),
        feature.install(
            "//metalos/initrd/vmtest:host-config",
            "/run/state/metalos/metalos_host_configs::host::HostConfig-current.json",
        ),
        feature.install(
            "//metalos/initrd/vmtest:host-config-boot_config",
            "/run/state/metalos/metalos_host_configs::boot_config::BootConfig-staged.json",
        ),
        feature.install("//metalos/initrd:initrd.cpio.gz", "/image/initrd/metalos.initrd:deadbeefdeadbeefdeadbeefdeadbeef"),
    ],
    parent_layer = "//metalos/disk:control",
)

image.layer(
    name = "rootfs",
    features = [
        feature.rpms_install([
            "efibootmgr",
            # required for TCTI shared libs
            "tpm2-tools",
        ]),
    ],
    parent_layer = "//metalos/os/vm:base",
)

btrfs.new(
    name = "test-root-disk",
    antlir_rule = "user-internal",
    opts = btrfs.opts.new(
        default_subvol = "/volume",
        free_mb = 2560,  # 2.5G
        loopback_opts = image.opts(
            label = "/",
        ),
        subvols = {
            "/volume": btrfs.opts.subvol.new(
                layer = ":control",
                writable = True,
            ),
            "/volume/image/kernel/kernel." + TEST_KERNEL.uname + ":deadbeefdeadbeefdeadbeefdeadbeef": btrfs.opts.subvol.new(
                layer = TEST_KERNEL.derived_targets.image,
            ),
            "/volume/image/rootfs/metalos:deadbeefdeadbeefdeadbeefdeadbeef": btrfs.opts.subvol.new(
                layer = ":rootfs",
            ),
        },
    ),
    visibility = [],
)

image.gpt(
    name = "gpt-boot-disk",
    table = [
        image.gpt_partition(
            is_esp = True,
            package = ":efi.vfat",
        ),
        image.gpt_partition(
            package = ":test-root-disk",
        ),
    ],
)

vm.run(
    name = "boot-from-disk",
    vm_opts = vm.types.opts.new(
        boot_from_disk = True,
        disk = vm.types.disk.new(
            interface = "nvme",
            package = ":gpt-boot-disk",
        ),
    ),
)

vm.rust_unittest(
    name = "test-boots-nvme",
    srcs = ["test_boot.rs"],
    crate_root = "test_boot.rs",
    vm_opts = vm.types.opts.new(
        boot_from_disk = True,
        disk = vm.types.disk.new(
            interface = "nvme",
            package = ":gpt-boot-disk",
        ),
    ),
    deps = third_party.libraries(
        [
            "anyhow",
            "nix",
        ],
        platform = "rust",
    ),
)

pe_hash(
    name = "bootloader_hash",
    algorithm = "sha1",
    binary = "//metalos/bootloader:bootloader.efi",
)

vm.rust_unittest(
    name = "test-measure-bootloader",
    srcs = ["test_measure_bootloader.rs"],
    crate_root = "test_measure_bootloader.rs",
    env = {
        "BOOTLOADER_HASH_FILE": "$(location :bootloader_hash)",
        "TCTI": "device:/dev/tpm0",
    },
    vm_opts = vm.types.opts.new(
        boot_from_disk = True,
        disk = vm.types.disk.new(
            interface = "nvme",
            package = ":gpt-boot-disk",
        ),
        runtime = vm.types.runtime.new(
            tpm = True,
        ),
    ),
    deps = third_party.libraries(
        [
            "anyhow",
            "base64",
            "derive_more",
            "fallible-iterator",
            "hex",
            "serde",
            "serde_json",
            "slog",
            "slog_glog_fmt",
            "tss-esapi",
            "uefi-eventlog",
            "ring",
        ],
        platform = "rust",
    ),
)
