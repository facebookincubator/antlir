load("@bazel_skylib//lib:paths.bzl", "paths")
load("//antlir/bzl:constants.bzl", "REPO_CFG")
load("//antlir/bzl:flavor_helpers.bzl", "flavor_helpers")
load("//antlir/bzl:hoist.bzl", "hoist")
load("//antlir/bzl:image.bzl", "image")
load("//antlir/bzl:kernel_shim.bzl", "kernels")
load("//antlir/bzl:oss_shim.bzl", "buck_genrule", "third_party")
load("//antlir/bzl:systemd.bzl", "systemd")
load("//antlir/bzl/genrule/extractor:extract.bzl", "extract")
load("//antlir/bzl/image/feature:defs.bzl", "feature")
load("//antlir/bzl/image/package:btrfs.bzl", "btrfs")
load("//antlir/bzl/image/package:defs.bzl", "package")
load("//antlir/bzl/linux:defs.bzl", "linux")
load("//antlir/vm/bzl:defs.bzl", "vm")
load("//metalos:defs.bzl", "rust_binary")
load(":hash.bzl", "pe_hash")

rust_binary(
    name = "metalos-bootloader",
    srcs = ["metalos_bootloader.rs"],
    # set some flags for a more size-optimized and statically-linked binary
    link_style = "static",
    linker_flags = [
        "-Wl,--strip-all",
    ],
    nodefaultlibs = True,
    rustc_flags = [
        "-C",
        "opt-level=z",
    ],
    deps = [
        "anyhow",
        "nix",
        "slog",
        "slog_glog_fmt",
        "tokio",
        "//metalos/host_configs/rust:metalos_host_configs",
        "//metalos/lib/blkid:blkid",
        "//metalos/lib/kexec:metalos_kexec",
        "//metalos/lib/metalos_paths:metalos_paths",
        "//metalos/lib/state:state",
    ],
)

image.layer(
    name = "with-metalos-bootloader",
    features = [
        feature.install(
            ":metalos-bootloader",
            "/usr/bin/metalos-bootloader",
            mode = "a+rx",
        ),
    ],
    parent_layer = REPO_CFG.artifact["metalos.layer.base"],
)

# Use the default kernel as the base for the EFI bootloader for two reasons:
# 1) compiling the kernel is slow and requires a large git clone
# 2) we can count on some small amount of support if we're using an official
#  kernel
KERNEL = kernels.default

image.layer(
    name = "initrd",
    features = [
        extract.extract(
            binaries = ["/usr/bin/metalos-bootloader"],
            source = ":with-metalos-bootloader",
        ),
        systemd.install_unit("metalos-bootloader.service"),
        feature.remove("/usr/lib/systemd/system/initrd.target"),
        systemd.install_unit("metalos-bootloader.target"),
        systemd.set_default_target(
            "metalos-bootloader.target",
            force = True,
        ),
        feature.remove("/usr/lib/initrd-release"),
        linux.release.install(
            layer = ":initrd",
            os_name = "MetalOS",
            path = "/usr/lib/os-release",
            variant = "Bootloader",
        ),
        feature.ensure_subdirs_exist(
            "/usr/lib",
            paths.join(
                "modules",
                KERNEL.uname,
            ),
        ),
        feature.install(
            KERNEL.derived_targets.disk_boot_modules,
            paths.join(
                "/usr/lib/modules",
                KERNEL.uname,
            ),
        ),
    ],
    parent_layer = "//metalos/initrd:initrd-common",
)

package.new(
    name = "initrd.cpio.gz",
    format = "cpio.gz",
    layer = ":initrd",
)

# man 7 systemd-stub
hoist(
    name = "systemd-stub",
    layer = REPO_CFG.artifact["metalos.layer.base"],
    path = "/usr/lib/systemd/boot/efi/linuxx64.efi.stub",
)

buck_genrule(
    name = "bootloader.efi",
    out = "out",
    cmd = """
        objcopy \
            --add-section .osrel="$(location :initrd__os-release)" --change-section-vma .osrel=0x20000 \
            --add-section .linux="$(location {vmlinuz})" --change-section-vma .linux=0x2000000 \
            --add-section .initrd="$(location :initrd.cpio.gz)" --change-section-vma .initrd=0x3000000 \
            "$(location :systemd-stub)" $OUT
    """.format(
        vmlinuz = KERNEL.derived_targets.vmlinuz,
    ),
)

image.layer(
    name = "efi",
    features = [
        feature.install(":bootloader.efi", "/EFI/Linux/metalos.efi"),
    ],
    flavor = flavor_helpers.get_antlir_linux_flavor(),
    parent_layer = "//antlir/bzl/linux/boot/systemd:base",
    visibility = ["//metalos/disk/..."],
)

package.new(
    name = "efi.vfat",
    format = "vfat",
    layer = ":efi",
    loopback_opts = image.opts(
        label = "efi",
        size_mb = 256,
    ),
)

TEST_KERNEL = kernels.default

image.layer(
    name = "control",
    features = [
        feature.ensure_dirs_exist("/run/state/metalos"),
        feature.ensure_dirs_exist("/image/initrd"),
        feature.install(
            "//metalos/initrd/vmtest:host-config",
            "/run/state/metalos/metalos_host_configs::host::HostConfig-current.json",
        ),
        feature.install(
            "//metalos/initrd/vmtest:host-config-boot_config",
            "/run/state/metalos/metalos_host_configs::boot_config::BootConfig-staged.json",
        ),
        feature.install("//metalos/initrd:initrd.cpio.gz", "/image/initrd/metalos.initrd:deadbeefdeadbeefdeadbeefdeadbeef"),
    ],
    parent_layer = "//metalos/disk:control",
)

image.layer(
    name = "rootfs",
    features = [
        feature.rpms_install([
            "efibootmgr",
            # required for TCTI shared libs
            "tpm2-tools",
        ]),
    ],
    parent_layer = "//metalos/os/vm:base",
)

btrfs.new(
    name = "test-root-disk",
    antlir_rule = "user-internal",
    opts = btrfs.opts.new(
        default_subvol = "/volume",
        free_mb = 2560,  # 2.5G
        loopback_opts = image.opts(
            label = "/",
        ),
        subvols = {
            "/volume": btrfs.opts.subvol.new(
                layer = ":control",
                writable = True,
            ),
            "/volume/image/kernel/kernel." + TEST_KERNEL.uname + ":deadbeefdeadbeefdeadbeefdeadbeef": btrfs.opts.subvol.new(
                layer = TEST_KERNEL.derived_targets.image,
            ),
            "/volume/image/rootfs/metalos:deadbeefdeadbeefdeadbeefdeadbeef": btrfs.opts.subvol.new(
                layer = ":rootfs",
            ),
        },
    ),
    visibility = [],
)

image.gpt(
    name = "gpt-boot-disk",
    table = [
        image.gpt_partition(
            is_esp = True,
            package = ":efi.vfat",
        ),
        image.gpt_partition(
            package = ":test-root-disk",
        ),
    ],
)

vm.run(
    name = "boot-from-disk",
    vm_opts = vm.types.opts.new(
        boot_from_disk = True,
        disk = vm.types.disk.new(
            interface = "nvme",
            package = ":gpt-boot-disk",
        ),
    ),
)

vm.rust_unittest(
    name = "test-boots-nvme",
    srcs = ["test_boot.rs"],
    crate_root = "test_boot.rs",
    vm_opts = vm.types.opts.new(
        boot_from_disk = True,
        disk = vm.types.disk.new(
            interface = "nvme",
            package = ":gpt-boot-disk",
        ),
    ),
    deps = third_party.libraries(
        [
            "anyhow",
            "nix",
        ],
        platform = "rust",
    ),
)

pe_hash(
    name = "bootloader_hash",
    algorithm = "sha1",
    binary = ":bootloader.efi",
)

vm.rust_unittest(
    name = "test-measure-bootloader",
    srcs = ["test_measure_bootloader.rs"],
    crate_root = "test_measure_bootloader.rs",
    env = {
        "BOOTLOADER_HASH_FILE": "$(location :bootloader_hash)",
        "TCTI": "device:/dev/tpm0",
    },
    vm_opts = vm.types.opts.new(
        boot_from_disk = True,
        disk = vm.types.disk.new(
            interface = "nvme",
            package = ":gpt-boot-disk",
        ),
        runtime = vm.types.runtime.new(
            tpm = True,
        ),
    ),
    deps = third_party.libraries(
        [
            "anyhow",
            "base64",
            "derive_more",
            "fallible-iterator",
            "hex",
            "serde",
            "serde_json",
            "slog",
            "slog_glog_fmt",
            "tss-esapi",
            "uefi-eventlog",
            "ring",
        ],
        platform = "rust",
    ),
)
