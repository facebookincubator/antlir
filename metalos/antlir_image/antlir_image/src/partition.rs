use std::collections::HashMap;

use crate::path::VerifiedPath;
use crate::subvolume::AntlirSubvolumes;

#[derive(Debug, thiserror::Error)]
pub enum PartitionError {
    #[error("Disk was missing expected partition {0}")]
    MissingPartition(u32),
}

pub struct Partition<S: AntlirSubvolumes> {
    pub number: u32,
    pub path: VerifiedPath,
    pub subvolumes: S,
}

impl<S: AntlirSubvolumes> Partition<S> {
    pub fn new_unchecked(number: u32, path: VerifiedPath) -> Self {
        Self {
            number,
            path,
            subvolumes: S::new_unchecked(),
        }
    }
}

/// A marker trait indicating that this struct is actually
/// generated by the macro below.
pub trait AntlirGPT: crate::AntlirPackaged {
    fn from_partition_map_unchecked(
        disk: VerifiedPath,
        partitions: HashMap<u32, VerifiedPath>,
    ) -> Result<Self, PartitionError>
    where
        Self: Sized;
}

#[macro_export]
macro_rules! generate_partitions {
    ($name:ident { $($part_name:ident ($subvols_type:ty, $part_num:tt)),* $(,)* }) => {
        pub struct $name {
            pub disk: $crate::path::VerifiedPath,
            $(
                pub $part_name: $crate::partition::Partition<$subvols_type>,
            )*
        }

        impl $crate::AntlirPackaged for $name {}
        impl $crate::partition::AntlirGPT for $name {
            #[allow(dead_code)]
            fn from_partition_map_unchecked(
                disk: $crate::path::VerifiedPath,
                mut partitions: ::std::collections::HashMap<u32, VerifiedPath>
            ) -> std::result::Result<Self, $crate::partition::PartitionError> {
                Ok(Self {
                    disk,
                    $(
                        $part_name: match partitions.remove(&$part_num) {
                            Some(path) => $crate::partition::Partition::new_unchecked(
                                $part_num,
                                path,
                            ),
                            None => {
                                return Err($crate::partition::PartitionError::MissingPartition($part_num));
                            }
                        },
                    )*
                })
            }
        }

        impl $name {
            #[allow(dead_code)]
            pub fn new_unchecked(
                disk: $crate::path::VerifiedPath,
                $($part_name: $crate::partition::Partition<$subvols_type>,)*
            ) -> Self {
                Self { disk, $($part_name,)* }
            }
        }

    };
}
