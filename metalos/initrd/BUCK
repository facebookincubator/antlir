# @noautodeps

load("@bazel_skylib//lib:new_sets.bzl", "sets")
load("//antlir/bzl:constants.bzl", "REPO_CFG")
load("//antlir/bzl:image.bzl", "image")
load("//antlir/bzl:oss_shim.bzl", "kernel_get")
load("//antlir/bzl:systemd.bzl", "systemd")
load("//antlir/bzl/genrule/extractor:extract.bzl", "extract")
load("//antlir/bzl/image/feature:defs.bzl", "feature")
load("//antlir/bzl/image/feature:usergroup.bzl", "SHELL_NOLOGIN")
load("//antlir/bzl/image/package:defs.bzl", "package")
load("//antlir/bzl/linux:busybox.bzl", "DEFAULT_APPLETS")
load("//antlir/bzl/linux:defs.bzl", "linux")
load(":systemd.bzl", "clone_systemd_configs", SYSTEMD_BINARIES = "BINARIES")

dbus = [
    feature.group_add("dbus"),
    feature.user_add("dbus", "dbus", "/", SHELL_NOLOGIN),
]

networking = [
    # Explicitly enable systemd-networkd to configure the network links
    # early in boot
    systemd.enable_unit("systemd-networkd.service"),
    systemd.enable_unit("systemd-networkd-wait-online.service"),
    # There is some opportunity to consolidate with the MetalOS root network
    # unit, but for right now we only want to use SLAAC in the initrd.
    feature.install("units/eth.network", "/usr/lib/systemd/network/50-eth.network"),
]

nss = linux.config.glibc.nsswitch.install(linux.config.glibc.nsswitch.default)

users = [
    feature.install("group", "/etc/group"),
    feature.install("passwd", "/etc/passwd"),
    feature.install("//antlir:empty", "/etc/shadow"),
    feature.install("//antlir:empty", "/usr/sbin/nologin"),
    feature.group_add("systemd-network"),
    feature.user_add(
        "systemd-network",
        "systemd-network",
        "/",
        SHELL_NOLOGIN,
    ),
]

udev = [
    image.ensure_subdirs_exist("/usr/lib/", "udev/rules.d"),
] + [
    feature.install(
        "udev/{}".format(f),
        "/usr/lib/udev/rules.d/{}".format(f),
    )
    for f in [
        "50-udev-default.rules",
        "60-block.rules",
        "60-persistent-storage.rules",
        "80-drivers.rules",
        "99-systemd.rules",
    ]
]

debug = [
    systemd.install_dropin("debug-shell.conf", "debug-shell.service"),
    systemd.install_dropin("emergency.conf", "emergency.service"),
]

image.layer(
    name = "busybox",
    flavor = REPO_CFG.antlir_linux_flavor,
    features = [
        image.rpms_install([
            "busybox",
        ]),
    ],
    visibility = ["//metalos/initrd/..."],
)

# A bare layer with only systemd essentials included
image.layer(
    name = "bare-systemd",
    features = [
        linux.filesystem.install(),
        clone_systemd_configs(REPO_CFG.artifact["metalos.layer.base"]),
        feature.ensure_file_symlink("/usr/lib/systemd/systemd", "/init"),
        # Systemd uses the presence of /etc/initrd-release to determine if it
        # is running in an initrd, however there are cases where it only parses
        # /{etc,usr/lib}/os-release, so just cover all our bases with symlinks
        linux.release.install(
            path = "/usr/lib/initrd-release",
            layer = ":bare-systemd",
            os_name = "MetalOS",
            variant = "Initrd",
        ),
        feature.ensure_file_symlink("/usr/lib/initrd-release", "/etc/initrd-release"),
        feature.ensure_file_symlink("/usr/lib/initrd-release", "/etc/os-release"),
        feature.ensure_file_symlink("/usr/lib/initrd-release", "/usr/lib/os-release"),
        # The metalos generator will rewrite the default target to
        # initrd.target, so explicitly set emergency.target as the default in
        # the image so that the boot clearly fails if the generator fails during
        # early boot for any reason
        systemd.set_default_target("emergency.target"),
        # With our custom setup, just enable initrd-cleanup.service directly in
        # initrd.target instead of going through initrd-parse-etc.service as normal
        systemd.enable_unit(
            "initrd-cleanup.service",
            target = "initrd.target",
        ),
        systemd.install_dropin(
            "dropins/reload-before-cleanup.conf",
            unit = "initrd-cleanup.service",
        ),
        dbus,
        nss,
        users,
        udev,
        extract.extract(
            binaries = SYSTEMD_BINARIES + [
                # Metalctl uses libblkid for device discover, so include
                # blkid.8 for debugging purposes.
                "/usr/sbin/blkid",
                "/usr/sbin/btrfs",
            ],
            dest = "/",
            source = REPO_CFG.artifact["metalos.layer.base"],
        ),
    ],
    flavor = REPO_CFG.antlir_linux_flavor,
    visibility = [
        "//ti/platform/edgeos/...",
    ],
)

image.layer(
    name = "with-metalctl",
    parent_layer = "//metalos/os:metalos",
    features = [
        feature.remove("/usr/bin/metalctl"),
        feature.install(
            "//metalos/metalctl:metalctl-initrd",
            "/usr/bin/metalctl",
            mode = "a+rx",
        ),
    ],
)

# Kernel-agnostic base initrd
image.layer(
    name = "initrd",
    parent_layer = ":bare-systemd",
    features = [
        linux.busybox.install(
            src = ":busybox",
            src_path = "/sbin/busybox",
            applets = sets.difference(
                DEFAULT_APPLETS,
                sets.make([
                    "mount",
                    "umount",
                ]),
            ),
        ),
        # metalctl's implementation of (u)mount works better, systemd passes
        # some options that busybox does not understand
        feature.ensure_file_symlink("/usr/bin/metalctl", "/usr/bin/mount"),
        feature.ensure_file_symlink("/usr/bin/metalctl", "/usr/bin/umount"),
        extract.extract(
            binaries = [
                "/usr/bin/metalctl",
            ],
            dest = "/",
            source = ":with-metalctl",
        ),
        networking,
        debug,
        image.ensure_subdirs_exist("/usr/lib", "tmpfiles.d"),
        feature.install("units/metalos.tmpfiles.conf", "/usr/lib/tmpfiles.d/metalos.conf"),
        systemd.install_unit("units/metalos-apply-host-config.service"),
        systemd.install_unit("units/metalos-fetch-images.service"),
        # We would one day like to make it so that
        # metalos-image-root-disk.service isn't even present in the normal
        # initrd and instead we have a separate one that is allowed to wipe the
        # disks. This would give an extra layer of safety and make it so that
        # disk reimage is a very explicit operation.
        systemd.install_unit("units/metalos-image-root-disk.service"),
        systemd.install_unit("units/metalos-load-host-config.service"),
        systemd.install_unit("units/metalos-snapshot-root.service"),
        systemd.install_unit("units/metalos-switch-root.service"),
        systemd.enable_unit("metalos-switch-root.service", "initrd-switch-root.target", "requires"),
        feature.ensure_file_symlink("/usr/bin/metalctl", "/usr/lib/systemd/system-generators/metalos-generator"),
        image.ensure_subdirs_exist("/usr/lib", "metalos"),
        # @oss-disable: "//metalos/initrd/facebook:features", 
    ],
    flavor = REPO_CFG.antlir_linux_flavor,
    visibility = [
        kernel_get.base_target + "/...",
        "//metalos/...",
        "//scripts/dschatzberg/vm:",
    ],
)

package.new(
    name = "initrd.cpio.gz",
    format = "cpio.gz",
    layer = ":initrd",
    visibility = ["PUBLIC"],
)
