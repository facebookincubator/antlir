load("@bazel_skylib//lib:paths.bzl", "paths")
load("//antlir/bzl:constants.bzl", "REPO_CFG")
load("//antlir/bzl:flavor_helpers.bzl", "flavor_helpers")
load("//antlir/bzl:image.bzl", "image")
load("//antlir/bzl:oss_shim.bzl", "kernel_get")
load("//antlir/bzl:systemd.bzl", "systemd")
load("//antlir/bzl/genrule/extractor:extract.bzl", "extract")
load("//antlir/bzl/image/feature:defs.bzl", "feature")
load("//antlir/bzl/image/feature:usergroup.bzl", "SHELL_NOLOGIN")
load("//antlir/bzl/image/package:defs.bzl", "package")
load("//antlir/bzl/linux:defs.bzl", "linux")
load(":initrd_release.bzl", "initrd_release")
load(":systemd.bzl", "clone_systemd_configs", SYSTEMD_BINARIES = "BINARIES")

# Generate /etc/initrd-release based on scm/fbpkg revision info
initrd_release(
    name = "initrd-release",
)

networking = [
    # Explicitly enable systemd-networkd to configure the network links
    # early in boot
    systemd.enable_unit("systemd-networkd.service"),
    systemd.enable_unit("systemd-networkd-wait-online.service"),
    # There is some opportunity to consolidate with the MetalOS root network
    # unit, but for right now we only want to use SLAAC in the initrd.
    feature.install("units/eth.network", "/usr/lib/systemd/network/50-eth.network"),
]

nss = linux.config.glibc.nsswitch.install(linux.config.glibc.nsswitch.default)

users = [
    feature.install("group", "/etc/group"),
    feature.install("passwd", "/etc/passwd"),
    feature.install("//antlir:empty", "/etc/shadow"),
    feature.install("//antlir:empty", "/usr/sbin/nologin"),
    feature.group_add("systemd-network"),
    feature.user_add(
        "systemd-network",
        "systemd-network",
        "/",
        SHELL_NOLOGIN,
    ),
]

udev = [
    image.ensure_subdirs_exist("/usr/lib/", "udev/rules.d"),
] + [
    image.clone(
        "//metalos/os:metalos",
        paths.join("usr/lib/udev/rules.d/", f),
        paths.join("usr/lib/udev/rules.d/", f),
    )
    for f in [
        "10-dm.rules",
        "50-udev-default.rules",
        "60-block.rules",
        "60-persistent-storage.rules",
        "80-drivers.rules",
        "95-dm-notify.rules",
        "99-systemd.rules",
    ]
]

# A bare layer with only systemd essentials included
image.layer(
    name = "bare-systemd",
    features = [
        linux.filesystem.install(),
        clone_systemd_configs("//metalos/os:metalos"),
        image.ensure_file_symlink("/usr/lib/systemd/systemd", "/init"),
        # Systemd uses the presence of /etc/initrd-release to determine if it
        # is running in an initrd, however there are cases where it only parses
        # /{etc,usr/lib}/os-release, so just cover all our bases with symlinks
        feature.install(":initrd-release", "/usr/lib/initrd-release"),
        image.ensure_file_symlink("/usr/lib/initrd-release", "/etc/initrd-release"),
        image.ensure_file_symlink("/usr/lib/initrd-release", "/usr/lib/os-release"),
        image.ensure_file_symlink("/usr/lib/initrd-release", "/etc/os-release"),
        # This is automatically the target that systemd tries to reach when it
        # detects /etc/initrd-release, but explicitly symlinking it makes
        # systemd-analyze work as expected too
        systemd.set_default_target("initrd.target"),
        # With our custom setup, just enable initrd-cleanup.service directly in
        # initrd.target instead of going through initrd-parse-etc.service as normal
        systemd.enable_unit(
            "initrd-cleanup.service",
            target = "initrd.target",
        ),
        systemd.install_dropin(
            "dropins/reload-before-cleanup.conf",
            unit = "initrd-cleanup.service",
        ),
        systemd.install_dropin(
            "dropins/udevd-before-trigger.conf",
            unit = "systemd-udevd.service",
        ),
        nss,
        users,
        udev,
        extract.extract(
            binaries = SYSTEMD_BINARIES + [
                "/usr/sbin/btrfs",
            ],
            dest = "/",
            source = "//metalos/os:metalos",
        ),
    ],
    flavor = REPO_CFG.antlir_linux_flavor,
    visibility = [
        "//ti/platform/edgeos/...",
    ],
)

# Kernel-agnostic base initrd
image.layer(
    name = "base",
    parent_layer = ":bare-systemd",
    features = [
        extract.extract(
            binaries = [
                "/usr/bin/metalctl",
            ],
            dest = "/",
            source = "//metalos/os:metalos",
        ),
        feature.install("//metalos/metalctl:default-config.toml", "/etc/metalctl.toml"),
        # metalctl provides a few utility binaries that systemd calls so we can
        # avoid importing busybox for just a few tiny commands
        image.ensure_file_symlink("/usr/bin/metalctl", "/usr/bin/mkdir"),
        image.ensure_file_symlink("/usr/bin/metalctl", "/usr/bin/mount"),
        image.ensure_file_symlink("/usr/bin/metalctl", "/usr/bin/umount"),
        networking,
        systemd.install_unit("units/metalos-fetch-image@.service"),
        systemd.install_unit("units/metalos-snapshot-root.service"),
        systemd.install_unit("units/metalos-apply-host-config.service"),
        systemd.install_unit("units/metalos-switch-root.service"),
        systemd.enable_unit("metalos-switch-root.service", "initrd-switch-root.target", "requires"),
        image.ensure_file_symlink("/usr/bin/metalctl", "/usr/lib/systemd/system-generators/metalos-generator"),
        image.ensure_subdirs_exist("/usr/lib", "metalos"),
        # generic metalos generators to be applied to the root fs
        "//metalos/host_configs:generators",
    ],
    flavor = REPO_CFG.antlir_linux_flavor,
    visibility = [
        kernel_get.base_target + "/...",
        "//metalos/...",
        "//scripts/dschatzberg/vm:",
    ],
)

# CPIO archive to which environment specific overlays are appended. For
# example, vmtest appends units that load required kernel modules and sets up
# the BTRFS seed device on /
package.new(
    name = "base.cpio.gz",
    format = "cpio.gz",
    layer = ":base",
    visibility = ["PUBLIC"],
    build_appliance = flavor_helpers.default_flavor_build_appliance,
)
